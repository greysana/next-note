#!/bin/bash

set -e

echo "üöÄ Starting Kubernetes deployment for Next.js app..."

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Check if Minikube is running
if ! minikube status &> /dev/null; then
    echo -e "${RED}‚ùå Minikube is not running. Starting Minikube...${NC}"
    minikube start --driver=docker
else
    echo -e "${GREEN}‚úÖ Minikube is already running${NC}"
fi

# Point Docker CLI to Minikube's Docker daemon
echo -e "${BLUE}üì¶ Configuring Docker to use Minikube's daemon...${NC}"
eval $(minikube docker-env)

# Build the Docker image inside Minikube
echo -e "${BLUE}üî® Building Docker image...${NC}"
docker-compose up --build -d

# Verify image was built
if docker images | grep -q "nextjs-app"; then
    echo -e "${GREEN}‚úÖ Docker image built successfully${NC}"
else
    echo -e "${RED}‚ùå Failed to build Docker image${NC}"
    exit 1
fi

# Apply ConfigMap for nginx
echo -e "${BLUE}üìù Applying nginx ConfigMap...${NC}"
kubectl apply -f k8s/nginx-configmap.yaml

# Apply Kubernetes deployments
echo -e "${BLUE}üö¢ Applying Kubernetes deployments...${NC}"
kubectl apply -f k8s/deployment.yaml

# Apply Kubernetes services
echo -e "${BLUE}üåê Applying Kubernetes services...${NC}"
kubectl apply -f k8s/service.yaml

# Wait for deployments to be ready
echo -e "${BLUE}‚è≥ Waiting for deployments to be ready...${NC}"
kubectl wait --for=condition=available --timeout=120s deployment/nextjs-app
kubectl wait --for=condition=available --timeout=120s deployment/nginx

# Get service URL
echo -e "${GREEN}‚úÖ Deployment completed successfully!${NC}"
echo ""
echo -e "${BLUE}üìä Deployment Status:${NC}"
kubectl get deployments
echo ""
echo -e "${BLUE}üîå Services:${NC}"
kubectl get services
echo ""
echo -e "${BLUE}üì¶ Pods:${NC}"
kubectl get pods
echo ""

# Get the Minikube IP and service URL
MINIKUBE_IP=$(minikube ip)
echo -e "${GREEN}üåç Access your application at: http://${MINIKUBE_IP}:30080${NC}"
echo ""
echo -e "${BLUE}üí° Useful commands:${NC}"
echo "  - View logs: kubectl logs -f deployment/nextjs-app"
echo "  - View nginx logs: kubectl logs -f deployment/nginx"
echo "  - Scale app: kubectl scale deployment nextjs-app --replicas=3"
echo "  - Delete all resources: kubectl delete -f k8s/deployment.yaml -f k8s/service.yaml -f k8s/nginx-configmap.yaml"
echo "  - Open in browser: minikube service nginx-service"
echo ""



docker compose
'services:
  nextjs-app:
    build: 
      context: .
      dockerfile: Dockerfile
      args:
        MONGODB_URI: ${MONGODB_URI}
        NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}
        NEXTAUTH_URL: ${NEXTAUTH_URL}
        NEXT_PUBLIC_SITE_URL: ${NEXT_PUBLIC_SITE_URL}
        OPENROUTER_API_KEY: ${OPENROUTER_API_KEY}
        OPENROUTER_MODEL: ${OPENROUTER_MODEL}
        REDIS_URL: ${REDIS_URL}
    ports:
      - "3000:3000"
    env_file:
      - .env
    restart: unless-stopped
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

dockerfile

# Dependencies stage
FROM node:18-alpine AS deps
WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production --ignore-scripts

# Builder stage
FROM node:18-alpine AS builder
WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .

# Build-time environment variables
ARG MONGODB_URI
ARG NEXTAUTH_SECRET
ARG NEXTAUTH_URL
ARG NEXT_PUBLIC_SITE_URL
ARG RESEND_API_KEY
ARG OPENROUTER_API_KEY
ARG OPENROUTER_MODEL
ARG REDIS_URL

ENV MONGODB_URI=$MONGODB_URI
ENV NEXTAUTH_SECRET=$NEXTAUTH_SECRET
ENV NEXTAUTH_URL=$NEXTAUTH_URL
ENV NEXT_PUBLIC_SITE_URL=$NEXT_PUBLIC_SITE_URL
ENV RESEND_API_KEY=$RESEND_API_KEY
ENV OPENROUTER_API_KEY=$OPENROUTER_API_KEY
ENV OPENROUTER_MODEL=$OPENROUTER_MODEL
ENV REDIS_URL=$REDIS_URL

RUN npm run build

# Runner stage
FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
COPY --from=builder --chown=nextjs:nodejs /app/public ./public

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]

deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nextjs-app
  labels:
    app: nextjs-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nextjs-app
  template:
    metadata:
      labels:
        app: nextjs-app
    spec:
      containers:
      - name: nextjs-app
        image: nextjs-app:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"  # Changed from development
        - name: HOSTNAME
          value: "0.0.0.0"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 3000
          initialDelaySeconds: 60  # Increased from 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 3000
          initialDelaySeconds: 30  # Increased from 10
          periodSeconds: 5
          timeoutSeconds: 5
          failureThreshold: 3
        startupProbe:  # Added startup probe
          httpGet:
            path: /
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 5
          failureThreshold: 12  # 60 seconds total (12 * 5s)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config

service.yaml

apiVersion: v1
kind: Service
metadata:
  name: nextjs-app-service
  labels:
    app: nextjs-app
spec:
  type: ClusterIP
  selector:
    app: nextjs-app
  ports:
  - protocol: TCP
    port: 3000
    targetPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  labels:
    app: nginx
spec:
  type: NodePort
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    nodePort: 30080


nginx-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  nginx.conf: |
    events {
      worker_connections 1024;
    }

    http {
      map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
      }

      upstream nextjs_app {
        server nextjs-app-service:3000;
        keepalive 32;
      }

      server {
        listen 80;
        server_name _;

        proxy_connect_timeout 120s;
        proxy_send_timeout    120s;
        proxy_read_timeout    120s;
        send_timeout          120s;

        proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
        
        location = /favicon.ico {
          access_log off;
          return 204;
        }

        location /health {
          access_log off;
          add_header Content-Type text/plain;
          return 200 'OK\n';
        }

        location / {
          proxy_pass http://nextjs_app;
          proxy_http_version 1.1;

          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection $connection_upgrade;

          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;
          proxy_set_header X-Forwarded-Host $host;

          proxy_cache_bypass $http_upgrade;
          proxy_buffering off;
        }

        location /_next/ {
          proxy_pass http://nextjs_app;
          proxy_http_version 1.1;

          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection $connection_upgrade;
          proxy_set_header Host $host;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

          proxy_cache_bypass $http_upgrade;
          proxy_buffering off;
        }
      }
    }

package json
{
  "name": "nextnote",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -H 0.0.0.0 -p 3000",
    "build": "next build",
    "start": "next start -H 0.0.0.0 -p 3000",
    "deploy": "",
    "lint": "next lint",
    "lint:fix": "next lint --fix",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "docker:build": "docker build -t nextjs-app .",
    "docker:run": "docker run -p 3000:3000 nextjs-app",
    "clean": "rm -rf .next out coverage test-results"
  },


  **

  import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "standalone",
  experimental: {
    optimizePackageImports: ["lucide-react"],
  },
  allowedDevOrigins: [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:54757",
    "http://127.0.0.1:54757",
  ],
};

export default nextConfig;
